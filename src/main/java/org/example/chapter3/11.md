## Item 11: Always override hashCode when you override equals

在重写equals方法时，必须同时重写hashCode方法。如果不这样做，你的类将违反hashCode的一般约定，这将导致它在HashMap和HashSet等集合中无法正常工作。下面是从Object规范中适应的约定：

- 当在应用程序的执行过程中多次调用hashCode方法时，只要没有修改用于equals比较的信息，它必须始终返回相同的值。这个值不需要在应用程序的不同执行之间保持一致。
- 如果两个对象根据equals方法是相等的，那么调用这两个对象的hashCode方法必须产生相同的整数结果。
- 如果两个对象根据equals方法是不相等的，不要求调用每个对象的hashCode方法必须产生不同的结果。然而，程序员应该意识到，为不相等的对象产生不同的结果可能会提高哈希表的性能。

当你没有重写hashCode方法时，违反的关键规定是：相等的对象必须具有相等的哈希码。两个不同的实例可能在类的equals方法中逻辑上是相等的，但对于Object的hashCode方法来说，它们只是两个没有太多共同之处的对象。因此，Object的hashCode方法返回两个看似随机的数字，而不是合同所要求的两个相等的数字。

例如，假设你尝试将PhoneNumber类的实例作为HashMap的键：
```java
Map<PhoneNumber, String> m = new HashMap<>();
m.put(new PhoneNumber(707, 867, 5309), "Jenny");
```
此时，你可能期望m.get(new PhoneNumber(707, 867, 5309))返回"Jenny"，但实际上它返回null。请注意，涉及两个PhoneNumber实例：一个用于插入到HashMap中，另一个相等的实例用于（尝试）检索。PhoneNumber类未重写hashCode导致这两个相等的实例具有不相等的哈希码，违反了hashCode的约定。因此，get方法很可能在与put方法存储的哈希桶不同的哈希桶中查找电话号码。即使这两个实例碰巧哈希到相同的桶中，如果哈希码不匹配，get方法几乎肯定会返回null，因为HashMap在每个条目中缓存与哈希码相关联的哈希码，并且如果哈希码不匹配，就不会检查对象的相等性。

修复这个问题就是为PhoneNumber编写一个正确的hashCode方法。那么hashCode方法应该是什么样的呢？写一个糟糕的hashCode方法是很简单的。例如，下面这个方法是合法的，但是绝对不应该使用：
```java
// 最糟糕的合法hashCode实现 - 永远不要使用！
@Override 
public int hashCode() {
        return 42;
}
```

这个方法是合法的，因为它确保相等的对象具有相同的哈希码。但是它是糟糕的，因为它确保每个对象都具有相同的哈希码。因此，每个对象都映射到相同的桶中，哈希表退化为链表。对于大型哈希表来说，这是工作与不工作之间的区别。

一个好的哈希函数倾向于为不相等的实例产生不相等的哈希码。这正是hashCode约定的第三部分所指的。理想情况下，一个哈希函数应该将任何合理的不相等实例均匀地分布到所有int值中。实现这个理想情况可能很困难。幸运的是，通过简单的方法也可以实现一个公平的近似。下面是一个简单的步骤：

1. 声明一个名为result的int变量，并将其初始化为对象中第一个重要字段的哈希码c，如步骤2.a中计算的那样。（回顾一下，重要字段是影响equals比较的字段。）
2. 对于对象中的每个剩余的重要字段f，执行以下操作：
   - 计算字段的哈希码c：
     - 如果字段是原始类型，计算Type.hashCode(f)，其中Type是与f的类型对应的装箱原始类。
     - 如果字段是对象引用，并且该类的equals方法通过递归调用equals来比较字段，则递归调用字段的hashCode方法。如果需要更复杂的比较，计算该字段的“规范表示”并调用hashCode方法。如果字段的值为null，则使用0（或其他常量，但传统上使用0）。
     - 如果字段是数组，则将其视为每个重要元素都是单独的字段。也就是说，通过递归应用这些规则为每个重要元素计算哈希码，并按照步骤2.b中的规则组合这些值。如果数组没有重要元素，则使用一个常量，最好不是0。如果所有元素都是重要的，则使用Arrays.hashCode。
   - 将步骤2.a中计算的哈希码c合并到result中，如下所示：
     ```java
     result = 31 * result + c;
     ```
3. 返回result。

当你完成编写hashCode方法后，问问自己相等的实例是否具有相等的哈希码。编写单元测试来验证你的直觉（除非你使用AutoValue来生成equals和hashCode方法，在这种情况下，你可以安全地省略这些测试）。如果相等的实例具有不相等的哈希码，找出原因并修复问题。

你可以排除派生字段的哈希码计算。换句话说，你可以忽略可以从计算中的字段计算出的任何字段的值。你必须排除任何在equals比较中未使用的字段，否则可能会违反hashCode约定的第二个规定。

在步骤2.b中的乘法使结果依赖于字段的顺序，从而在类具有多个相似字段时产生更好的哈希函数。例如，如果在String的哈希函数中省略了乘法，所有的变位词将具有相同的哈希码。选择值为31的原因是因为它是一个奇素数。如果它是偶数并且乘法溢出，就会丢失信息，因为乘以2等于移位。使用素数的好处不太明显，但这是传统的做法。31的一个好的特性是，可以通过移位和减法来替换乘法，以在某些体系结构上提高性能：31 * i == (i << 5) - i。现代虚拟机会自动进行这种优化。

让我们将上述方法应用于PhoneNumber类：
```java
// 典型的hashCode方法
@Override 
public int hashCode() {
    int result = Short.hashCode(areaCode);
    result = 31 * result + Short.hashCode(prefix);
    result = 31 * result + Short.hashCode(lineNum);
    return result;
}
```

因为这个方法返回一个简单的确定性计算的结果，其唯一的输入是PhoneNumber实例中的三个重要字段，所以很明显相等的PhoneNumber实例具有相等的哈希码。实际上，这个方法对于PhoneNumber来说是一个完全好的hashCode实现，与Java平台库中的实现相当。它简单、相对快速，并且在将不相等的电话号码分散到不同的哈希桶中方面做了一个合理的工作。

虽然本条目中的方法提供了相当好的哈希函数，但它们并不是最先进的。它们在质量上与Java平台库的值类型中的哈希函数相当，并且对于大多数用途来说是足够的。如果你真正需要更不容易产生冲突的哈希函数，请参考Guava的com.google.common.hash.Hashing [Guava]。

Objects类有一个静态方法，它接受任意数量的对象并为它们返回一个哈希码。这个方法叫做hash，它让你可以编写一行的hashCode方法，其质量与按照本条目中的方法编写的方法相当。不幸的是，它运行得更慢，因为它需要创建数组来传递可变数量的参数，并且如果任何参数是原始类型，则需要装箱和拆箱。这种类型的哈希函数只推荐在性能不是关键的情况下使用。下面是使用这种技术编写的PhoneNumber的哈希函数：
```java
// 一行hashCode方法 - 中等性能
@Override 
public int hashCode() {
    return Objects.hash(lineNum, prefix, areaCode);
}
```

如果一个类是不可变的，并且计算哈希码的成本很高，你可以考虑将哈希码缓存在对象中，而不是每次请求时重新计算。如果你认为这种类型的大多数对象将被用作哈希键，那么你应该在实例创建时计算哈希码。否则，你可以选择在第一次调用hashCode时延迟初始化哈希码。在延迟初始化字段的情况下，需要注意确保类在存在延迟初始化字段的情况下仍然是线程安全的（参见条目83）。我们的PhoneNumber类不需要这种处理，但为了向你展示如何做到这一点，这里是一个例子。注意，hashCode字段的初始值（在这种情况下为0）不应该是常见创建实例的哈希码：
```java
// 带有延迟初始化缓存哈希码的hashCode方法
private int hashCode; // 自动初始化为0
@Override 
public int hashCode() {
    int result = hashCode;
    if (result == 0) {
        result = Short.hashCode(areaCode);
        result = 31 * result + Short.hashCode(prefix);
        result = 31 * result + Short.hashCode(lineNum);
        hashCode = result;
    }
    return result;
}
```

不要试图排除重要字段的哈希码计算以提高性能。虽然结果哈希函数可能运行得更快，但其质量可能会降低到使哈希表无法使用的程度。特别是，哈希函数可能面临一个大集合的实例，这些实例在你选择忽略的区域主要不同。如果发生这种情况，哈希函数将把所有这些实例映射到几个哈希码，并且应该在线性时间内运行的程序将以二次时间运行。

不要为hashCode返回的值提供详细的规范，这样客户端就不能合理地依赖它；这使得你可以灵活地更改它。Java库中的许多类（如String和Integer）指定了它们的hashCode方法返回值的确切值作为实例值的函数。这不是一个好主意，但是我们被迫接受这个错误：它阻碍了在将来的版本中改进哈希函数的能力。如果你将细节留给不确定，并且在哈希函数中发现了一个缺陷或者发现了一个更好的哈希函数，你可以在后续版本中进行更改。

总之，每当你重写equals时，你必须重写hashCode，否则你的程序将无法正确运行。你的hashCode方法必须遵守Object中指定的一般约定，并且必须合理地为不相等的实例分配不相等的哈希码。使用本条目中的方法很容易实现，尽管可能有些乏味。正如在条目10中提到的，AutoValue框架提供了一个很好的手动编写equals和hashCode方法的替代方法，而且IDE也提供了一些这方面的功能。

在Java中，如果你重写了equals方法，就必须同时重写hashCode方法。这是因为在使用哈希表等数据结构时，它们依赖于对象的hashCode来确定对象在内存中的存储位置，而equals方法用于比较两个对象是否相等。

如果你只重写了equals方法而没有重写hashCode方法，那么在使用哈希表等数据结构时，可能会出现以下问题：
- 相等的对象可能会被认为是不相等的，因为它们的hashCode不同。
- 在查找对象时，可能无法正确地找到对象，因为哈希表使用的是hashCode来确定对象的存储位置。

因此，为了确保程序的正确运行，你必须始终重写hashCode方法，以便它与equals方法保持一致。

在重写hashCode方法时，你需要遵循一些规则：
- 相等的对象必须具有相等的hashCode。
- 不相等的对象可以具有相等的hashCode，但最好是不相等的对象具有不同的hashCode，以提高哈希表的性能。

为了编写一个好的hashCode方法，你可以按照以下步骤进行：
1. 声明一个名为result的int变量，并将其初始化为对象中第一个重要字段的hashCode值。
2. 对于对象中的每个其他重要字段，按照以下方式计算hashCode：
   - 如果字段是基本类型，使用Type.hashCode(field)来计算hashCode，其中Type是与字段类型对应的包装类。
   - 如果字段是对象引用，并且该类的equals方法通过递归调用equals来比较字段，则递归调用字段的hashCode方法。如果需要进行更复杂的比较，则计算字段的“规范表示”并调用hashCode方法。如果字段的值为null，则使用0（或其他常量，但传统上使用0）。
   - 如果字段是数组，则将其视为每个重要元素都是单独的字段。即，通过递归应用这些规则计算每个重要元素的hashCode，并根据步骤2.b将这些值组合起来。如果数组没有重要元素，则使用一个常量，最好不是0。如果所有元素都是重要的，则使用Arrays.hashCode。
3. 返回result作为hashCode的结果。

通过按照这个步骤编写hashCode方法，你可以确保相等的对象具有相等的hashCode，并且不相等的对象具有不同的hashCode。这样，哈希表等数据结构就可以正确地使用hashCode来确定对象的存储位置和比较对象的相等性。

总之，重写equals方法时，必须同时重写hashCode方法，以确保程序的正确运行。按照一定的规则编写hashCode方法，可以保证相等的对象具有相等的hashCode，并且不相等的对象具有不同的hashCode。