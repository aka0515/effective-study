# Item 15: 最小化类和成员的可访问性

Java编程语言的核心是类和接口。它们是其基本的抽象单元。语言提供了许多强大的元素，您可以使用这些元素来设计类和接口。本章包含一些建议，以帮助您充分利用这些元素，使您的类和接口可用、健壮和灵活。

### Item 15: 最小化类和成员的可访问性

区分组件的设计优良的最重要因素，是组件在多大程度上隐藏其内部数据和其他实现细节，以使其对其他组件不可见。一个设计良好的组件应该**尽可能地隐藏其所有实现细节，**从而实现了其API（提供的访问接口）与实现的清晰分离。

组件之间应该仅通过API进行通信，对彼此的内部工作毫不知情。这被称为信息隐藏或封装，是软件设计的基本原则之一。信息隐藏之所以重要，是因为它实现了组件之间的解耦，使得这些组件能够独立开发、测试、优化、使用、理解和修改。信息隐藏给软件开发带来了诸多好处，例如加快了系统开发进度，降低了维护的难度，并提高了软件的重用性等。

Java提供了许多辅助实现信息隐藏的机制。访问控制机制规定了类、接口和成员的可访问性。一个实体的可访问性取决于其声明位置，以及声明时使用的访问修饰符（private、protected和public）。正确使用这些修饰符对于信息隐藏至关重要。简单来说，我们应该**尽量将类或成员的可访问性设置得尽可能低**，即使用与所编写的软件正常运行相一致的最低可访问级别。

对于顶级（非嵌套）类和接口来说，只有两个可能的访问级别：包级私有（package-private）和公共（public）。如果使用public修饰符声明顶级类或接口，它将是公共的；否则，它将是包级私有的。如果顶级类或接口可以设置为包级私有，那么应该尽量设置为包级私有。将其设置为包级私有，可以使其成为实现的一部分，而不是导出的API。在以后的发布版本中，可以对其进行修改、替换或删除，而无需担心会影响现有客户端的使用。如果将其设置为公共的，就有义务永远支持它以保持向后兼容性。

**如果一个包级私有的顶级类或接口仅被一个类使用，那么应该将该顶级类作为该类的私有静态嵌套类**（Item 24）。这样做可以将其可访问性从其所在包中的所有类降低到只有使用它的类可见。但是，与其过度降低公共类的可访问性相比，请优先降低包级私有的顶级类的可访问性。因为公共类是包的API的一部分，而包级私有的顶级类已经是其实现的一部分。

对于成员（字段、方法、嵌套类和嵌套接口）来说，有四个可能的访问级别，按照可访问性递增的顺序列出：

- private：只有在声明它的顶级类中可访问该成员。
- 包级私有：该成员可在声明它所在包中的任何类中访问。这是默认访问级别，如果没有指定其他访问修饰符（接口成员是默认为public的）。
- protected：该成员对声明它的类的子类可见（受一些限制[JLS, 6.6.2]）并且对声明它的包中的任何类可见。
- public：该成员对任何位置都可见。

在精心设计类的公共API之后，我们应该将所有其他成员设置为私有（类）。只有当位于同一包中的另一个类确实需要访问某个成员时，我们才应该将成员的可访问性提升为包级私有。如果我们经常这样做，应该重新审视系统设计，看看是否有另一种分解方式可以实现更好的类解耦。值得注意的是，私有和包级私有的成员只属于类的实现部分，通常不会影响其导出的API。然而，如果类实现了Serializable接口（Item 86和87），这些字段可能会“泄露”到导出的API中。

对于公共类的成员来说，访问级别从包级私有提升到受保护级别，则会造成可访问性的巨大增加。受保护级别的成员是类的公共API的一部分，必须永久支持。此外，一个导出类的受保护成员表示对实现细节的公共承诺（Item 19）。因此，对受保护成员的需求应该相对较少。

方法的可访问级别受到了一个重要规则的限制。如果一个方法覆盖了超类的方法，在子类中它的访问级别不能比超类中的访问级别更严格（JLS, 8.4.8.3）。这是为了确保子类的实例可以在任何可以使用超类实例的地方使用，即满足里氏替换原则（Liskov substitution principle，详见Item 15）。如果违反了这个规则，当试图编译子类时，编译器会生成一个错误消息。对于实现接口的类，这个规则的一个特例是，类中的实现接口的方法都必须被声明为public。

在测试代码时，您可能会有诱惑使类、接口或成员比其本来的访问级别更可访问。这在某种程度上是可以接受的。为了测试公共类中的私有成员，将其设置为包级私有以进行测试是可以接受的，但将其可访问性提高到更高级别是不可接受的。换句话说，不可接受的是将类、接口或成员作为软件包的导出API的一部分来便于测试。幸运的是，这也是不必要的，因为测试可以作为要测试的软件包的一部分来运行，并获得对其包级私有元素的访问权限。

公共类的实例字段很少应该是公共的（Item 16）。如果一个实例字段是非final的或者是对可变对象的引用，那么将其设置为公共的意味着您放弃了对可以存储在字段中的值进行限制的能力。这意味着您放弃了对字段相关不变式的强制执行能力。此外，您还放弃了在字段被修改时采取任何操作的灵活性，所以具有公共可变字段的类通常不是线程安全的。即使字段是final的并且引用的是不可变对象，将其设置为公共也会放弃切换到新的内部数据表示的灵活性，其中不再存在该字段。对于静态字段也适用相同的建议，但有一个例外情况。您可以通过使用public static final字段来公开常量，前提是这些常量是类提供的抽象的一个组成部分。按照约定，这些字段的名称由大写字母组成，单词之间用下划线分隔（Item 68）。重要的是这些字段应该包含原始值或对不可变对象的引用（Item 17）。包含对可变对象引用的字段具有所有非final字段的缺点。尽管无法修改引用本身，但引用的对象却可以被修改，结果可能是灾难性的。

请注意，非零长度的数组是可变的，因此一个类具有公共静态final数组字段或返回这样一个字段的访问器是错误的。如果一个类具有这样的字段或访问器，客户端将有能力修改数组的内容。这是一个常见的安全漏洞的来源：

```java
// 潜在的安全漏洞！
public static final Thing[] VALUES = { ... };
```

请注意，一些集成开发环境（IDE）生成的访问器返回对私有数组字段的引用，从而导致了与此问题完全相同的问题。有两种方法来解决这个问题。一种方法是将公共数组字段设置为私有，并添加一个公共的不可变列表：

```java
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```

另一种方法是将数组设置为私有，并添加一个公共方法，该方法返回私有数组的副本：

```java
private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}
```

在选择这些替代方案时，要考虑客户端可能对结果采取的操作。哪种返回类型更方便？哪种返回类型将提供更好的性能？

从Java 9开始，随着模块化系统的引入，还引入了两个附加的隐式访问级别。模块是包的组合，就像包是类的组合一样。模块可以通过其模块声明中的导出声明显式导出其中的一些包（通常包含在名为module-info.java的源文件中）。模块中未导出的包的公共和受保护成员在模块外是无法访问的，但在模块内，导出声明不会影响其可访问性。使用模块化系统可以在模块内的各个包之间共享类，而无需将它们公开给整个世界。未导出包中公共和受保护类的公共成员对应着这两个隐式访问级别，它们与正常的公共和受保护级别在模块内是类似的。需要这种共享的情况相对较少，而且通常可以通过重新组织包中的类来避免。

与主要的四个访问级别不同，这两个基于模块的级别在很大程度上是指导性的。如果将一个模块的JAR文件放置在应用程序的类路径上而不是模块路径上，模块中的包将恢复到其非模块化行为：这些包中的公共和受保护类的公共成员将恢复其正常的可访问性，而不管这些包是否被模块导出（Reinhold, 1.2）。新引入的访问级别严格地在JDK本身中执行：Java库中未导出的包在其模块之外是无法访问的。

对于典型的Java程序员来说，模块提供的访问保护的效用有限且主要是指导性质的；为了使用它，必须将包分组为模块，明确声明所有依赖关系，重新组织源代码树，并对来自模块化以外的包的访问进行特殊处理（Reinhold, 3）。目前来说，除了JDK自身以外，模块是否会在其他地方得到广泛使用还为时过早。因此，在没有迫切需求的情况下，最好避免使用模块。

总之，应该尽量降低程序元素的可访问性（在合理的范围内）并在精心设计公共API之后，防止任何无关的类、接口或成员成为API的一部分。除了公共静态final字段（用作常量）之外，公共类不应该有公共字段。确保由公共静态final字段引用的对象是不可变的。